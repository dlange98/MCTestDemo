"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const commandline_1 = require("../../../util/commandline");
const interaction_1 = require("../../../util/interaction");
const index_1 = require("../../../util/profile/index");
const util_1 = require("util");
const fs = require("fs");
const pfs = require("../../../util/misc/promisfied-fs");
const chalk = require("chalk");
const update_contents_tasks_1 = require("../lib/update-contents-tasks");
const file_utils_1 = require("../lib/file-utils");
const environment_1 = require("../lib/environment");
const validation_utils_1 = require("../lib/validation-utils");
const index_2 = require("../lib/release-strategy/index");
const environment_vars_1 = require("../../../util/profile/environment-vars");
const debug = require("debug")("appcenter-cli:commands:codepush:release-skeleton");
class CodePushReleaseCommandSkeleton extends commandline_1.AppCommand {
    constructor(args) {
        super(args);
        // Ð¡urrently use old service due to we have limitation of 1MB payload limit through bifrost service
        this.releaseStrategy = new index_2.LegacyCodePushRelease();
    }
    run(client) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("For dev purposes only!");
        });
    }
    release(client) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rollout = Number(this.specifiedRollout);
            const validationResult = yield this.validate(client);
            if (!validationResult.succeeded) {
                return validationResult;
            }
            this.deploymentName = this.specifiedDeploymentName;
            if (this.privateKeyPath) {
                yield update_contents_tasks_1.sign(this.privateKeyPath, this.updateContentsPath);
            }
            const updateContentsZipPath = yield update_contents_tasks_1.zip(this.updateContentsPath);
            try {
                const app = this.app;
                const serverUrl = this.getServerUrl();
                const token = this.token || environment_vars_1.getTokenFromEnvironmentVar() || (yield index_1.getUser().accessToken);
                yield interaction_1.out.progress("Creating CodePush release...", this.releaseStrategy.release(client, app, this.deploymentName, updateContentsZipPath, {
                    appVersion: this.targetBinaryVersion,
                    description: this.description,
                    isDisabled: this.disabled,
                    isMandatory: this.mandatory,
                    rollout: this.rollout
                }, token, serverUrl));
                interaction_1.out.text(`Successfully released an update containing the "${this.updateContentsPath}" `
                    + `${fs.lstatSync(this.updateContentsPath).isDirectory() ? "directory" : "file"}`
                    + ` to the "${this.deploymentName}" deployment of the "${this.app.appName}" app.`);
                return commandline_1.success();
            }
            catch (error) {
                if (error.response && error.response.statusCode === 409 && this.disableDuplicateReleaseError) {
                    // 409 (Conflict) status code means that uploaded package is identical
                    // to the contents of the specified deployment's current release
                    console.warn(chalk.yellow("[Warning] " + error.response.body));
                    return commandline_1.success();
                }
                else {
                    debug(`Failed to release a CodePush update - ${util_1.inspect(error)}`);
                    return commandline_1.failure(commandline_1.ErrorCodes.Exception, error.response ? error.response.body : error);
                }
            }
            finally {
                yield pfs.rmDir(updateContentsZipPath);
            }
        });
    }
    getServerUrl() {
        const environment = environment_1.environments(this.getEnvironmentName());
        return environment && environment.managementEndpoint;
    }
    getEnvironmentName() {
        if (this.environmentName) {
            return this.environmentName;
        }
        const user = index_1.getUser();
        if (user) {
            return user.environment;
        }
    }
    validate(client) {
        return __awaiter(this, void 0, void 0, function* () {
            if (file_utils_1.isBinaryOrZip(this.updateContentsPath)) {
                return commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, "It is unnecessary to package releases in a .zip or binary file. Please specify the direct path to the update content's directory (e.g. /platforms/ios/www) or file (e.g. main.jsbundle).");
            }
            if (!validation_utils_1.isValidRange(this.targetBinaryVersion)) {
                return commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, "Invalid binary version(s) for a release.");
            }
            if (!Number.isSafeInteger(this.rollout) || !validation_utils_1.isValidRollout(this.rollout)) {
                return commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `Rollout value should be integer value between ${chalk.bold("0")} or ${chalk.bold("100")}.`);
            }
            if (!this.deploymentName && !(yield validation_utils_1.isValidDeployment(client, this.app, this.specifiedDeploymentName))) {
                return commandline_1.failure(commandline_1.ErrorCodes.InvalidParameter, `Deployment "${this.specifiedDeploymentName}" does not exist.`);
            }
            return commandline_1.success();
        });
    }
}
__decorate([
    commandline_1.help("Deployment to release the update to"),
    commandline_1.shortName("d"),
    commandline_1.longName("deployment-name"),
    commandline_1.defaultValue("Staging"),
    commandline_1.hasArg
], CodePushReleaseCommandSkeleton.prototype, "specifiedDeploymentName", void 0);
__decorate([
    commandline_1.help("Description of the changes made to the app in this release"),
    commandline_1.longName("description"),
    commandline_1.hasArg
], CodePushReleaseCommandSkeleton.prototype, "description", void 0);
__decorate([
    commandline_1.help("Specifies whether this release should be immediately downloadable"),
    commandline_1.shortName("x"),
    commandline_1.longName("disabled")
], CodePushReleaseCommandSkeleton.prototype, "disabled", void 0);
__decorate([
    commandline_1.help("Specifies whether this release should be considered mandatory"),
    commandline_1.shortName("m"),
    commandline_1.longName("mandatory")
], CodePushReleaseCommandSkeleton.prototype, "mandatory", void 0);
__decorate([
    commandline_1.help("Specifies the location of a RSA private key to sign the release with." + chalk.yellow("NOTICE:") + " use it for react native applications only, client SDK on other platforms will be ignoring signature verification for now!"),
    commandline_1.shortName("k"),
    commandline_1.longName("private-key-path"),
    commandline_1.hasArg
], CodePushReleaseCommandSkeleton.prototype, "privateKeyPath", void 0);
__decorate([
    commandline_1.help("When this flag is set, releasing a package that is identical to the latest release will produce a warning instead of an error"),
    commandline_1.longName("disable-duplicate-release-error")
], CodePushReleaseCommandSkeleton.prototype, "disableDuplicateReleaseError", void 0);
__decorate([
    commandline_1.help("Percentage of users this release should be available to"),
    commandline_1.shortName("r"),
    commandline_1.longName("rollout"),
    commandline_1.defaultValue("100"),
    commandline_1.hasArg
], CodePushReleaseCommandSkeleton.prototype, "specifiedRollout", void 0);
exports.default = CodePushReleaseCommandSkeleton;
