"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const unzip = require("unzip");
const xmldom_1 = require("xmldom");
class XmlUtil {
    collectAllElements(element, name) {
        let result = [];
        if (!element || !name) {
            return result;
        }
        if (element.nodeName === name) {
            result.push(element);
        }
        for (let i = 0; element.childNodes && i < element.childNodes.length; ++i) {
            result = result.concat(this.collectAllElements(element.childNodes[i], name));
        }
        return result;
    }
    collectChildren(element, name) {
        if (!element || !name) {
            return [];
        }
        if (element.nodeName === name) {
            return [element];
        }
        let result = [];
        for (let i = 0; element.childNodes && i < element.childNodes.length; ++i) {
            result = result.concat(this.collectChildren(element.childNodes[i], name));
        }
        return result;
    }
    countChildren(element) {
        if (!element || !element.childNodes) {
            return 0;
        }
        let result = element.childNodes.length;
        for (let i = 0; i < element.childNodes.length; ++i) {
            result += this.countChildren(element.childNodes[i]);
        }
        return result;
    }
    getMergeXmlResultsPromise(pathToArchive, tempPath, processXml, resolvePromise) {
        return new Promise((resolve, reject) => {
            fs.createReadStream(pathToArchive)
                .pipe(unzip.Parse())
                .on("entry", function (entry) {
                // Skip directories and hidden system files
                if (entry.type === "Directory" || path.basename(entry.path).substring(0, 1) === ".") {
                    return;
                }
                const fullPath = path.join(tempPath, entry.path);
                entry.pipe(fs.createWriteStream(fullPath).on("close", () => {
                    try {
                        processXml(fullPath, entry);
                    }
                    catch (e) {
                        reject(e);
                    }
                }));
            })
                .on("close", () => {
                resolvePromise(resolve);
            });
        });
    }
}
// Handle DOMParser warnings, errors and fatalErrors like JS exceptions
XmlUtil.DOMParserConfig = {
    locator: {},
    errorHandler: function (level, msg) {
        throw `DOMParser${level}: ${msg}`;
    }
};
exports.XmlUtil = XmlUtil;
function validXmlFile(file) {
    try {
        const xml = new xmldom_1.DOMParser(XmlUtil.DOMParserConfig).parseFromString(fs.readFileSync(file, "utf-8"), "text/xml");
        return xml != null;
    }
    catch (_a) {
        return false;
    }
}
exports.validXmlFile = validXmlFile;
